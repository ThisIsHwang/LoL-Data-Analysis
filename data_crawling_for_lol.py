# -*- coding: utf-8 -*-
"""롤_데이터수집.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MWsUrpEpe2rFGRFQetVLZvPn9WgRxmwC
"""

import requests
import pandas as pd
import pickle
import matplotlib.pyplot as plt
import numpy as np
import sys
import os
from pandas import json_normalize
import seaborn as sns
import time
import numpy as np

api_key = 'RGAPI-737e5936-3255-415e-bd6f-4bb96a1d58da'
sohwansaName = "국제트페연맹장"  # 소환사 닉네임
sohwan = "https://kr.api.riotgames.com/lol/summoner/v4/summoners/by-name/" + sohwansaName + '?api_key=' + api_key
r = requests.get(sohwan)

r.json()

import pandas as pd

league_df = pd.DataFrame()
for tier in ['I', 'II', 'III', 'IV']:
    #for i in range(1, 10):
    golduser = "https://kr.api.riotgames.com/lol/league/v4/entries/RANKED_FLEX_SR/DIAMOND/" + tier + "?page=" + str(1) + '&api_key=' + api_key
    r = requests.get(golduser)  # 유저데이터 호출
    temp_league_df = pd.DataFrame(r.json())
    league_df = pd.concat([league_df, temp_league_df])
league_df.reset_index(inplace=True)  # 수집한 유저데이터 index정리
league_df
print(league_df)
league_df = league_df.drop(['index', 'queueType', 'leagueId'], axis=1)
league_df.info()
league_df["tier"].unique()
league_df["tier"].value_counts()
league_df.to_csv('diamond.csv', index=False, encoding='cp949')  # 중간저장

league_df



league_df["puuid"] = np.NaN
for i in range(len(league_df)):
#for i in range(10):
    try:
        print(i)
        sohwan = 'https://kr.api.riotgames.com/lol/summoner/v4/summoners/' + league_df['summonerId'].iloc[i] + '?api_key=' + api_key
        r = requests.get(sohwan)

        while r.status_code == 429:
            time.sleep(5)
            sohwan = 'https://kr.api.riotgames.com/lol/summoner/v4/summoners/by-name/' + league_df['summonerId'].iloc[i] + '?api_key=' + api_key
            r = requests.get(sohwan)

        puu_id = r.json()['puuid']
        print(puu_id)
        league_df['puuid'].iloc[i] = puu_id

    except Exception as e:
        continue
league_df
league_df.to_csv('league_df.csv', index=False, encoding='cp949')  # 중간저장
league_df["puuid"]

# 13시즌의 데이터만을 이용할 것이며 league_df3 => 기존에 수집한 account_id가 있는 league_df
match_info_df = pd.DataFrame()
print(len(league_df))
for i in range(len(league_df)):
#for i in range(10):
    try:
        match0 = "https://asia.api.riotgames.com/lol/match/v5/matches/by-puuid/" + league_df['puuid'].iloc[i] + "/ids?start=0&count=20&api_key=" + api_key

        r = requests.get(match0)
        # print(r)
        while r.status_code == 429:
            time.sleep(5)
            match0 = "https://asia.api.riotgames.com/lol/match/v5/matches/by-puuid/" + league_df['puuid'].iloc[i] + "/ids?start=0&count=20&api_key=" + api_key
            r = requests.get(match0)

        match_info_df = pd.concat([match_info_df, pd.DataFrame(r.json(), columns=["matchId"])])

    except:
        print(i)

match_info_df
match_info_df.to_csv('match_info_df.csv', index=False, encoding='cp949')  # 중간저장

match_fin = pd.DataFrame()
# print(match_info_df)
for i in range(len(match_info_df)):
    api_url = "https://asia.api.riotgames.com/lol/match/v5/matches/" + str(match_info_df['matchId'].iloc[i]) + "?api_key=" + api_key
    r = requests.get(api_url)

    if r.status_code == 200:  # response가 정상이면 바로 맨 밑으로 이동하여 정상적으로 코드 실행
        pass

    elif r.status_code == 429:
        print('api cost full : infinite loop start')
        print('loop location : ', i)
        start_time = time.time()

        while True:  # 429error가 끝날 때까지 무한 루프
            if r.status_code == 429:

                print('try 10 second wait time')
                time.sleep(10)

                r = requests.get(api_url)
                print(r.status_code)

            elif r.status_code == 200:  # 다시 response 200이면 loop escape
                print('total wait time : ', time.time() - start_time)
                print('recovery api cost')
                break

    elif r.status_code == 503:  # 잠시 서비스를 이용하지 못하는 에러
        print('service available error')
        start_time = time.time()

        while True:
            if r.status_code == 503 or r.status_code == 429:

                print('try 10 second wait time')
                time.sleep(10)

                r = requests.get(api_url)
                print(r.status_code)

            elif r.status_code == 200:  # 똑같이 response가 정상이면 loop escape
                print('total error wait time : ', time.time() - start_time)
                print('recovery api cost')
                break
    elif r.status_code == 403:  # api갱신이 필요
        print('you need api renewal')
        print('break')
        break

    print(list(r.json()["info"].keys()))
    print(list(r.json()["info"].values()))

    mat = pd.DataFrame(list(r.json()["info"].values())).T
    match_fin = pd.concat([match_fin, mat])

match_fin.columns = ['gameCreation', 'gameDuration', 'gameEndTimestamp', 'gameId', 'gameMode', 'gameName',
                     'gameStartTimestamp', 'gameType', 'gameVersion', 'mapId', 'participants', 'platformId', 'queueId',
                     'teams', 'tournamentCode']
match_fin

match_fin
match_fin.to_csv('diamond_final.csv', index=False, encoding='cp949')  # 중간저장


# a팀 b팀 분리
team_a_error = []
team_b_error = []
team_a = pd.DataFrame()
team_b = pd.DataFrame()
for i in range(len(match_fin)):
    if i % 1000 == 0:
        print(str(i) + '행 처리중')
    try:
        team_a = team_a.append(json_normalize(match_fin['teams'].iloc[i][0]))
        team_b = team_b.append(json_normalize(match_fin['teams'].iloc[i][1]))
    except:
        team_a_error.append(i)
        team_b_error.append(i)
        print(str(i) + '행에서 오류')
        pass

team_a

# 각 경기별 게임 시간 병합
match_fin = match_fin.drop(index=team_a_error)

team_a['gameDuration'] = match_fin['gameDuration'].tolist()
team_b['gameDuration'] = match_fin['gameDuration'].tolist()

match_fin['gameDuration'].index = range(len(match_fin))
team_a['gameDuration'].index = range(len(team_a))
team_b['gameDuration'].index = range(len(team_b))
team_b

game_df = pd.concat([team_a, team_b], axis=0)
game_df.head()

tf_mapping = {True: 1, False: 0}
bool_column = game_df.select_dtypes('bool').columns.tolist()
print(bool_column)
for i in bool_column:
    game_df[i] = game_df[i].map(tf_mapping)

game_df

game_df[game_df['win'] == 1].describe()
